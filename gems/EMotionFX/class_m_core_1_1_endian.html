<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine EMotionFX Gem API Reference: MCore::Endian Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference<span id="projectnumber">&#160;23.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_m_core_1_1_endian.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_m_core_1_1_endian-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MCore::Endian Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Endian.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aefd74b4672115b5bf5a4f108141fe10d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> { <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10dacf6a6200b2decb05db43a30f0da6b24e">ENDIAN_LITTLE</a> = 0
, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10dabcef248bdcceb8d7fe2dbd81dbc4c8b6">ENDIAN_BIG</a> = 1
 }</td></tr>
<tr class="separator:aefd74b4672115b5bf5a4f108141fe10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2f550367f67eafdf926c9e9febe48a38"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a2f550367f67eafdf926c9e9febe48a38">ConvertUnsignedInt16</a> (uint16 *value, uint32 count=1)</td></tr>
<tr class="separator:a2f550367f67eafdf926c9e9febe48a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36eef37ef8d97fe4c19059555ab8e3c4"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a36eef37ef8d97fe4c19059555ab8e3c4">ConvertUnsignedInt32</a> (uint32 *value, uint32 count=1)</td></tr>
<tr class="separator:a36eef37ef8d97fe4c19059555ab8e3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4fb46742b7e646091e9e2237c53d74"><td class="memItemLeft" align="right" valign="top"><a id="adb4fb46742b7e646091e9e2237c53d74" name="adb4fb46742b7e646091e9e2237c53d74"></a>
static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertUnsignedInt64</b> (uint64 *value, uint32 count=1)</td></tr>
<tr class="separator:adb4fb46742b7e646091e9e2237c53d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f79d71c3c47107d7278c3c6a72380d8"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a3f79d71c3c47107d7278c3c6a72380d8">ConvertSignedInt16</a> (int16 *value, uint32 count=1)</td></tr>
<tr class="separator:a3f79d71c3c47107d7278c3c6a72380d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b09a5572ec0eb942cd8dbb297800b03"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a9b09a5572ec0eb942cd8dbb297800b03">ConvertSignedInt32</a> (int32 *value, uint32 count=1)</td></tr>
<tr class="separator:a9b09a5572ec0eb942cd8dbb297800b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45630b7f3ec2baebc39d281a7b4c43c3"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a45630b7f3ec2baebc39d281a7b4c43c3">ConvertFloat</a> (float *value, uint32 count=1)</td></tr>
<tr class="separator:a45630b7f3ec2baebc39d281a7b4c43c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7838f0e033ca78cf16b2a1e063f6c21c"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a7838f0e033ca78cf16b2a1e063f6c21c">ConvertVector2</a> (AZ::Vector2 *value, uint32 count=1)</td></tr>
<tr class="separator:a7838f0e033ca78cf16b2a1e063f6c21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fdffda9d0dc06a21512bd9ee16fdc8"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#ab7fdffda9d0dc06a21512bd9ee16fdc8">ConvertVector3</a> (AZ::Vector3 *value, uint32 count=1)</td></tr>
<tr class="separator:ab7fdffda9d0dc06a21512bd9ee16fdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1465812610793bcf78d8331e63ecef"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a1b1465812610793bcf78d8331e63ecef">ConvertVector4</a> (AZ::Vector4 *value, uint32 count=1)</td></tr>
<tr class="separator:a1b1465812610793bcf78d8331e63ecef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9408bce1c1e53c60d0f0bd321bdd76c"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#ac9408bce1c1e53c60d0f0bd321bdd76c">ConvertQuaternion</a> (AZ::Quaternion *value, uint32 count=1)</td></tr>
<tr class="separator:ac9408bce1c1e53c60d0f0bd321bdd76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced033a547a8b956c1756ba866cca80b"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#aced033a547a8b956c1756ba866cca80b">Convert16BitQuaternion</a> (<a class="el" href="class_m_core_1_1_t_compressed_quaternion.html">MCore::Compressed16BitQuaternion</a> *value, uint32 count=1)</td></tr>
<tr class="separator:aced033a547a8b956c1756ba866cca80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafbce815533251b2093c95a9f3f0e9f"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#abafbce815533251b2093c95a9f3f0e9f">ConvertRGBAColor</a> (<a class="el" href="class_m_core_1_1_r_g_b_a_color.html">MCore::RGBAColor</a> *value, uint32 count=1)</td></tr>
<tr class="separator:abafbce815533251b2093c95a9f3f0e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4467fed23e3c1f54f10cb8b1d3d98a8"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#ae4467fed23e3c1f54f10cb8b1d3d98a8">SwapBytes</a> (uint8 *byteA, uint8 *byteB)</td></tr>
<tr class="separator:ae4467fed23e3c1f54f10cb8b1d3d98a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb1a75753b123589d32f82a22d5f467"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#acdb1a75753b123589d32f82a22d5f467">ConvertEndian16</a> (uint8 *buffer, uint32 count=1)</td></tr>
<tr class="separator:acdb1a75753b123589d32f82a22d5f467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b72eb796324d25a1cb1f05e879d84f5"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a7b72eb796324d25a1cb1f05e879d84f5">ConvertEndian32</a> (uint8 *buffer, uint32 count=1)</td></tr>
<tr class="separator:a7b72eb796324d25a1cb1f05e879d84f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b91166910e6f63aaed1b5e432b9d864"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a7b91166910e6f63aaed1b5e432b9d864">ConvertEndian64</a> (uint8 *buffer, uint32 count=1)</td></tr>
<tr class="separator:a7b91166910e6f63aaed1b5e432b9d864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fb26240a6e4c2a2ac372a2d7ebe19c"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#ac9fb26240a6e4c2a2ac372a2d7ebe19c">ConvertFloat</a> (float *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:ac9fb26240a6e4c2a2ac372a2d7ebe19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21686b015f6c4831b13025ceeaebf2c2"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a21686b015f6c4831b13025ceeaebf2c2">ConvertSignedInt32</a> (int32 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:a21686b015f6c4831b13025ceeaebf2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6f5a2f5c2a3af3e62f16f389489413"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a6e6f5a2f5c2a3af3e62f16f389489413">ConvertUnsignedInt32</a> (uint32 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:a6e6f5a2f5c2a3af3e62f16f389489413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1266244e2d0a566d9b3a9d8af1d0550c"><td class="memItemLeft" align="right" valign="top"><a id="a1266244e2d0a566d9b3a9d8af1d0550c" name="a1266244e2d0a566d9b3a9d8af1d0550c"></a>
static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertUnsignedInt64</b> (uint64 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:a1266244e2d0a566d9b3a9d8af1d0550c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2f6eaec79103d9284a228658918fba"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a7e2f6eaec79103d9284a228658918fba">ConvertSignedInt16</a> (int16 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:a7e2f6eaec79103d9284a228658918fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0552cbcf788d704be9abc8e169c7462a"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a0552cbcf788d704be9abc8e169c7462a">ConvertUnsignedInt16</a> (uint16 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:a0552cbcf788d704be9abc8e169c7462a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ff210a606c5b34e545a210b7054a90"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a92ff210a606c5b34e545a210b7054a90">ConvertVector2</a> (AZ::Vector2 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:a92ff210a606c5b34e545a210b7054a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04c7d611fc97d1869c7641c34b69176"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#ac04c7d611fc97d1869c7641c34b69176">ConvertVector3</a> (AZ::Vector3 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:ac04c7d611fc97d1869c7641c34b69176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03781aad8620dd97e95247f7ae7ccac9"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a03781aad8620dd97e95247f7ae7ccac9">ConvertVector4</a> (AZ::Vector4 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:a03781aad8620dd97e95247f7ae7ccac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0712aa3f5239d4cf553850621974db7"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#ac0712aa3f5239d4cf553850621974db7">ConvertQuaternion</a> (AZ::Quaternion *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:ac0712aa3f5239d4cf553850621974db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f22b81e5b94a1e354db3c9a8eb4102a"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a5f22b81e5b94a1e354db3c9a8eb4102a">Convert16BitQuaternion</a> (<a class="el" href="class_m_core_1_1_t_compressed_quaternion.html">MCore::Compressed16BitQuaternion</a> *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:a5f22b81e5b94a1e354db3c9a8eb4102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fd8c093fbfdc4691de3d71397ecea4"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#ac8fd8c093fbfdc4691de3d71397ecea4">ConvertRGBAColor</a> (<a class="el" href="class_m_core_1_1_r_g_b_a_color.html">MCore::RGBAColor</a> *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, uint32 count=1)</td></tr>
<tr class="separator:ac8fd8c093fbfdc4691de3d71397ecea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030b82380f558e2646081509c9a8a4a3"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a030b82380f558e2646081509c9a8a4a3">ConvertFloat</a> (float *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a030b82380f558e2646081509c9a8a4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc32c87e621a641fb1b790d98457114"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a8dc32c87e621a641fb1b790d98457114">ConvertSignedInt32</a> (int32 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a8dc32c87e621a641fb1b790d98457114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b9a4f2d98085a01367b41ed738a6fe"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#ae9b9a4f2d98085a01367b41ed738a6fe">ConvertUnsignedInt32</a> (uint32 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:ae9b9a4f2d98085a01367b41ed738a6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e2306b57a8df85d46ed2b8a5553f91"><td class="memItemLeft" align="right" valign="top"><a id="a43e2306b57a8df85d46ed2b8a5553f91" name="a43e2306b57a8df85d46ed2b8a5553f91"></a>
static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertUnsignedInt64</b> (uint64 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a43e2306b57a8df85d46ed2b8a5553f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa7a7f21c0c1569cdd3f8d77b5a378e"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a3fa7a7f21c0c1569cdd3f8d77b5a378e">ConvertSignedInt16</a> (int16 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a3fa7a7f21c0c1569cdd3f8d77b5a378e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0443272115fb6830aacac368983f38"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#abc0443272115fb6830aacac368983f38">ConvertUnsignedInt16</a> (uint16 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:abc0443272115fb6830aacac368983f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4c77a592c5535f4d8df18cc0c39efa"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a4f4c77a592c5535f4d8df18cc0c39efa">ConvertVector2</a> (AZ::Vector2 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a4f4c77a592c5535f4d8df18cc0c39efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b3eac6b4a2faedb291d497d6b9c042"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#ab8b3eac6b4a2faedb291d497d6b9c042">ConvertVector3</a> (AZ::Vector3 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:ab8b3eac6b4a2faedb291d497d6b9c042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9031551c5a92c41b8890592b860177a0"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a9031551c5a92c41b8890592b860177a0">ConvertVector4</a> (AZ::Vector4 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a9031551c5a92c41b8890592b860177a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd22c6074d55094cfa1d8094bb0e865"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a8dd22c6074d55094cfa1d8094bb0e865">ConvertQuaternion</a> (AZ::Quaternion *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a8dd22c6074d55094cfa1d8094bb0e865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98da15ff1a96c3e7fd24ea5cfd6cf13b"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a98da15ff1a96c3e7fd24ea5cfd6cf13b">Convert16BitQuaternion</a> (<a class="el" href="class_m_core_1_1_t_compressed_quaternion.html">MCore::Compressed16BitQuaternion</a> *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a98da15ff1a96c3e7fd24ea5cfd6cf13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eead1fe2036fe28ae5a216ff6b58bb"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#aa0eead1fe2036fe28ae5a216ff6b58bb">ConvertRGBAColor</a> (<a class="el" href="class_m_core_1_1_r_g_b_a_color.html">MCore::RGBAColor</a> *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> sourceEndianType, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:aa0eead1fe2036fe28ae5a216ff6b58bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16aac2a90fe4722af5f09dfbf42d06db"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a16aac2a90fe4722af5f09dfbf42d06db">ConvertFloatTo</a> (float *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a16aac2a90fe4722af5f09dfbf42d06db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544e7d7e26ab851616202378297c6f63"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a544e7d7e26ab851616202378297c6f63">ConvertSignedInt32To</a> (int32 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a544e7d7e26ab851616202378297c6f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261b229fbe430085efc1b579a97c34dd"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a261b229fbe430085efc1b579a97c34dd">ConvertUnsignedInt32To</a> (uint32 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a261b229fbe430085efc1b579a97c34dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000c1d2f6c9ff6dda67ba20c2c835704"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a000c1d2f6c9ff6dda67ba20c2c835704">ConvertSignedInt16To</a> (int16 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a000c1d2f6c9ff6dda67ba20c2c835704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bb3834664a438d8dbc429288c93d1f"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a19bb3834664a438d8dbc429288c93d1f">ConvertUnsignedInt16To</a> (uint16 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a19bb3834664a438d8dbc429288c93d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abd6c1b59e72bc88228a378b22886a4"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a1abd6c1b59e72bc88228a378b22886a4">ConvertVector2To</a> (AZ::Vector2 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a1abd6c1b59e72bc88228a378b22886a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b0c300ff797950f959432d440ea72b"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a16b0c300ff797950f959432d440ea72b">ConvertVector3To</a> (AZ::Vector3 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a16b0c300ff797950f959432d440ea72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8624ba4cc6c30b4de6906df3b58c666f"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a8624ba4cc6c30b4de6906df3b58c666f">ConvertVector4To</a> (AZ::Vector4 *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a8624ba4cc6c30b4de6906df3b58c666f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429025637c7a7431d3311702120569b8"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a429025637c7a7431d3311702120569b8">ConvertQuaternionTo</a> (AZ::Quaternion *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a429025637c7a7431d3311702120569b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45eddff13ec8a890aa3a137f12f2d9ac"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#a45eddff13ec8a890aa3a137f12f2d9ac">Convert16BitQuaternionTo</a> (<a class="el" href="class_m_core_1_1_t_compressed_quaternion.html">MCore::Compressed16BitQuaternion</a> *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:a45eddff13ec8a890aa3a137f12f2d9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b7d1aec81b31f9c56579da40a7e955"><td class="memItemLeft" align="right" valign="top">static MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_endian.html#ab1b7d1aec81b31f9c56579da40a7e955">ConvertRGBAColorTo</a> (<a class="el" href="class_m_core_1_1_r_g_b_a_color.html">MCore::RGBAColor</a> *value, <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a> targetEndianType, uint32 count=1)</td></tr>
<tr class="separator:ab1b7d1aec81b31f9c56579da40a7e955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The endian class is a collection of static functions that allow you to convert specific object types into another endian conversion. This is useful when loading files from disk, which are stored in another endian than the platform you are running your code on. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aefd74b4672115b5bf5a4f108141fe10d" name="aefd74b4672115b5bf5a4f108141fe10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd74b4672115b5bf5a4f108141fe10d">&#9670;&#160;</a></span>EEndianType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">MCore::Endian::EEndianType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The supported endian conversion types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aefd74b4672115b5bf5a4f108141fe10dacf6a6200b2decb05db43a30f0da6b24e" name="aefd74b4672115b5bf5a4f108141fe10dacf6a6200b2decb05db43a30f0da6b24e"></a>ENDIAN_LITTLE&#160;</td><td class="fielddoc"><p>Least significant bits have lowest memory address </p>
</td></tr>
<tr><td class="fieldname"><a id="aefd74b4672115b5bf5a4f108141fe10dabcef248bdcceb8d7fe2dbd81dbc4c8b6" name="aefd74b4672115b5bf5a4f108141fe10dabcef248bdcceb8d7fe2dbd81dbc4c8b6"></a>ENDIAN_BIG&#160;</td><td class="fielddoc"><p>Most significant bits have lowest memory address </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a98da15ff1a96c3e7fd24ea5cfd6cf13b" name="a98da15ff1a96c3e7fd24ea5cfd6cf13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98da15ff1a96c3e7fd24ea5cfd6cf13b">&#9670;&#160;</a></span>Convert16BitQuaternion() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::Convert16BitQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_t_compressed_quaternion.html">MCore::Compressed16BitQuaternion</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a 16-bit compressed Quaternion object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the value is currently stored in, before conversion. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f22b81e5b94a1e354db3c9a8eb4102a" name="a5f22b81e5b94a1e354db3c9a8eb4102a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f22b81e5b94a1e354db3c9a8eb4102a">&#9670;&#160;</a></span>Convert16BitQuaternion() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MCORE_INLINE void MCore::Endian::Convert16BitQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_t_compressed_quaternion.html">MCore::Compressed16BitQuaternion</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a 16-bit compressed Quaternion object into the endian used by our current platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to convert the endian for. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the object is currently stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aced033a547a8b956c1756ba866cca80b" name="aced033a547a8b956c1756ba866cca80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced033a547a8b956c1756ba866cca80b">&#9670;&#160;</a></span>Convert16BitQuaternion() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::Convert16BitQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_t_compressed_quaternion.html">MCore::Compressed16BitQuaternion</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the endian of one or more 16-bit compressed Quaternion objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert the endian for. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to convert. Please note that the array specified by value must be large enough! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45eddff13ec8a890aa3a137f12f2d9ac" name="a45eddff13ec8a890aa3a137f12f2d9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45eddff13ec8a890aa3a137f12f2d9ac">&#9670;&#160;</a></span>Convert16BitQuaternionTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::Convert16BitQuaternionTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_t_compressed_quaternion.html">MCore::Compressed16BitQuaternion</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a 16-bit compressed Quaternion object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdb1a75753b123589d32f82a22d5f467" name="acdb1a75753b123589d32f82a22d5f467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb1a75753b123589d32f82a22d5f467">&#9670;&#160;</a></span>ConvertEndian16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertEndian16 </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Switches the endian (little or big) of a set of 16 bit values. This means the byte order gets inverted. A byte order of (B1 B2) gets converted into (B2 B1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The input buffer that points to the data containing the values to be converted. </td></tr>
    <tr><td class="paramname">count</td><td>The number of 16 bit values to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b72eb796324d25a1cb1f05e879d84f5" name="a7b72eb796324d25a1cb1f05e879d84f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b72eb796324d25a1cb1f05e879d84f5">&#9670;&#160;</a></span>ConvertEndian32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertEndian32 </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Switches the endian (little or big) of a set of 32 bit values. This means the byte order gets inverted. A byte order of (B1 B2 B3 B4) gets converted into (B4 B3 B2 B1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The input buffer that points to the data containing the values to be converted. </td></tr>
    <tr><td class="paramname">count</td><td>The number of 32 bit values to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b91166910e6f63aaed1b5e432b9d864" name="a7b91166910e6f63aaed1b5e432b9d864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b91166910e6f63aaed1b5e432b9d864">&#9670;&#160;</a></span>ConvertEndian64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertEndian64 </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Switches the endian (little or big) of a set of 64 bit values. This means the byte order gets inverted. A byte order of (B1 B2 B3 B4 B5 B6 B7 B8) gets converted into (B8 B7 B6 B5 B4 B3 B2 B1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The input buffer that points to the data containing the values to be converted. </td></tr>
    <tr><td class="paramname">count</td><td>The number of 64 bit values to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a030b82380f558e2646081509c9a8a4a3" name="a030b82380f558e2646081509c9a8a4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030b82380f558e2646081509c9a8a4a3">&#9670;&#160;</a></span>ConvertFloat() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertFloat </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a floating point value into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the value is currently stored in, before conversion. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9fb26240a6e4c2a2ac372a2d7ebe19c" name="ac9fb26240a6e4c2a2ac372a2d7ebe19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fb26240a6e4c2a2ac372a2d7ebe19c">&#9670;&#160;</a></span>ConvertFloat() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MCORE_INLINE void MCore::Endian::ConvertFloat </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert one or more 32 bit floating point values into the endian used by our current platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value(s) to convert. The number of values to follow at the specified address must be at least the number that you pass to the count parameter. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the float is currently stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of floats to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45630b7f3ec2baebc39d281a7b4c43c3" name="a45630b7f3ec2baebc39d281a7b4c43c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45630b7f3ec2baebc39d281a7b4c43c3">&#9670;&#160;</a></span>ConvertFloat() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertFloat </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the endian of one or more floats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert the endian for. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to convert. Please note that the array specified by value must be large enough! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16aac2a90fe4722af5f09dfbf42d06db" name="a16aac2a90fe4722af5f09dfbf42d06db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16aac2a90fe4722af5f09dfbf42d06db">&#9670;&#160;</a></span>ConvertFloatTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertFloatTo </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a floating point value into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dd22c6074d55094cfa1d8094bb0e865" name="a8dd22c6074d55094cfa1d8094bb0e865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd22c6074d55094cfa1d8094bb0e865">&#9670;&#160;</a></span>ConvertQuaternion() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertQuaternion </td>
          <td>(</td>
          <td class="paramtype">AZ::Quaternion *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Quaternion object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the value is currently stored in, before conversion. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0712aa3f5239d4cf553850621974db7" name="ac0712aa3f5239d4cf553850621974db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0712aa3f5239d4cf553850621974db7">&#9670;&#160;</a></span>ConvertQuaternion() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MCORE_INLINE void MCore::Endian::ConvertQuaternion </td>
          <td>(</td>
          <td class="paramtype">AZ::Quaternion *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Quaternion object into the endian used by our current platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to convert the endian for. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the object is currently stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9408bce1c1e53c60d0f0bd321bdd76c" name="ac9408bce1c1e53c60d0f0bd321bdd76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9408bce1c1e53c60d0f0bd321bdd76c">&#9670;&#160;</a></span>ConvertQuaternion() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertQuaternion </td>
          <td>(</td>
          <td class="paramtype">AZ::Quaternion *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the endian of one or more Quaternion objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert the endian for. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to convert. Please note that the array specified by value must be large enough! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a429025637c7a7431d3311702120569b8" name="a429025637c7a7431d3311702120569b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429025637c7a7431d3311702120569b8">&#9670;&#160;</a></span>ConvertQuaternionTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertQuaternionTo </td>
          <td>(</td>
          <td class="paramtype">AZ::Quaternion *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Quaternion object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0eead1fe2036fe28ae5a216ff6b58bb" name="aa0eead1fe2036fe28ae5a216ff6b58bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0eead1fe2036fe28ae5a216ff6b58bb">&#9670;&#160;</a></span>ConvertRGBAColor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertRGBAColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_r_g_b_a_color.html">MCore::RGBAColor</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an <a class="el" href="class_m_core_1_1_r_g_b_a_color.html">RGBAColor</a> object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the value is currently stored in, before conversion. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8fd8c093fbfdc4691de3d71397ecea4" name="ac8fd8c093fbfdc4691de3d71397ecea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fd8c093fbfdc4691de3d71397ecea4">&#9670;&#160;</a></span>ConvertRGBAColor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MCORE_INLINE void MCore::Endian::ConvertRGBAColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_r_g_b_a_color.html">MCore::RGBAColor</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a <a class="el" href="class_m_core_1_1_r_g_b_a_color.html">RGBAColor</a> object into the endian used by our current platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to convert the endian for. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the object is currently stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abafbce815533251b2093c95a9f3f0e9f" name="abafbce815533251b2093c95a9f3f0e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafbce815533251b2093c95a9f3f0e9f">&#9670;&#160;</a></span>ConvertRGBAColor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertRGBAColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_r_g_b_a_color.html">MCore::RGBAColor</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the endian of one or more <a class="el" href="class_m_core_1_1_r_g_b_a_color.html">RGBAColor</a> objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert the endian for. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to convert. Please note that the array specified by value must be large enough! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1b7d1aec81b31f9c56579da40a7e955" name="ab1b7d1aec81b31f9c56579da40a7e955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b7d1aec81b31f9c56579da40a7e955">&#9670;&#160;</a></span>ConvertRGBAColorTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertRGBAColorTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_r_g_b_a_color.html">MCore::RGBAColor</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an <a class="el" href="class_m_core_1_1_r_g_b_a_color.html">RGBAColor</a> object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fa7a7f21c0c1569cdd3f8d77b5a378e" name="a3fa7a7f21c0c1569cdd3f8d77b5a378e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa7a7f21c0c1569cdd3f8d77b5a378e">&#9670;&#160;</a></span>ConvertSignedInt16() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertSignedInt16 </td>
          <td>(</td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an 16 bit short into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the value is currently stored in, before conversion. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e2f6eaec79103d9284a228658918fba" name="a7e2f6eaec79103d9284a228658918fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2f6eaec79103d9284a228658918fba">&#9670;&#160;</a></span>ConvertSignedInt16() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertSignedInt16 </td>
          <td>(</td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert one or more 16 bit short values into the endian used by our current platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value(s) to convert. The number of values to follow at the specified address must be at least the number that you pass to the count parameter. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the short is currently stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of shorts to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f79d71c3c47107d7278c3c6a72380d8" name="a3f79d71c3c47107d7278c3c6a72380d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f79d71c3c47107d7278c3c6a72380d8">&#9670;&#160;</a></span>ConvertSignedInt16() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertSignedInt16 </td>
          <td>(</td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the endian of one or more shorts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert the endian for. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to convert. Please note that the array specified by value must be large enough! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a000c1d2f6c9ff6dda67ba20c2c835704" name="a000c1d2f6c9ff6dda67ba20c2c835704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000c1d2f6c9ff6dda67ba20c2c835704">&#9670;&#160;</a></span>ConvertSignedInt16To()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertSignedInt16To </td>
          <td>(</td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an 16 bit short into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dc32c87e621a641fb1b790d98457114" name="a8dc32c87e621a641fb1b790d98457114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc32c87e621a641fb1b790d98457114">&#9670;&#160;</a></span>ConvertSignedInt32() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertSignedInt32 </td>
          <td>(</td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a 32 bit int32 into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the value is currently stored in, before conversion. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21686b015f6c4831b13025ceeaebf2c2" name="a21686b015f6c4831b13025ceeaebf2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21686b015f6c4831b13025ceeaebf2c2">&#9670;&#160;</a></span>ConvertSignedInt32() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MCORE_INLINE void MCore::Endian::ConvertSignedInt32 </td>
          <td>(</td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert one or more 32 bit integer values into the endian used by our current platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value(s) to convert. The number of values to follow at the specified address must be at least the number that you pass to the count parameter. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the int32 is currently stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of integers to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b09a5572ec0eb942cd8dbb297800b03" name="a9b09a5572ec0eb942cd8dbb297800b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b09a5572ec0eb942cd8dbb297800b03">&#9670;&#160;</a></span>ConvertSignedInt32() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertSignedInt32 </td>
          <td>(</td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the endian of one or more ints. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert the endian for. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to convert. Please note that the array specified by value must be large enough! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a544e7d7e26ab851616202378297c6f63" name="a544e7d7e26ab851616202378297c6f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544e7d7e26ab851616202378297c6f63">&#9670;&#160;</a></span>ConvertSignedInt32To()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertSignedInt32To </td>
          <td>(</td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a 32 bit int32 into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc0443272115fb6830aacac368983f38" name="abc0443272115fb6830aacac368983f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0443272115fb6830aacac368983f38">&#9670;&#160;</a></span>ConvertUnsignedInt16() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertUnsignedInt16 </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an unsigned 16 bit short into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the value is currently stored in, before conversion. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0552cbcf788d704be9abc8e169c7462a" name="a0552cbcf788d704be9abc8e169c7462a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0552cbcf788d704be9abc8e169c7462a">&#9670;&#160;</a></span>ConvertUnsignedInt16() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MCORE_INLINE void MCore::Endian::ConvertUnsignedInt16 </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert one or more 16 bit uint16 values into the endian used by our current platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value(s) to convert. The number of values to follow at the specified address must be at least the number that you pass to the count parameter. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the short is currently stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of shorts to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f550367f67eafdf926c9e9febe48a38" name="a2f550367f67eafdf926c9e9febe48a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f550367f67eafdf926c9e9febe48a38">&#9670;&#160;</a></span>ConvertUnsignedInt16() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertUnsignedInt16 </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the endian of one or more unsigned shorts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert the endian for. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to convert. Please note that the array specified by value must be large enough! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19bb3834664a438d8dbc429288c93d1f" name="a19bb3834664a438d8dbc429288c93d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bb3834664a438d8dbc429288c93d1f">&#9670;&#160;</a></span>ConvertUnsignedInt16To()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertUnsignedInt16To </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an unsigned 16 bit short into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9b9a4f2d98085a01367b41ed738a6fe" name="ae9b9a4f2d98085a01367b41ed738a6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b9a4f2d98085a01367b41ed738a6fe">&#9670;&#160;</a></span>ConvertUnsignedInt32() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertUnsignedInt32 </td>
          <td>(</td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a 32 bit uint32 into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the value is currently stored in, before conversion. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e6f5a2f5c2a3af3e62f16f389489413" name="a6e6f5a2f5c2a3af3e62f16f389489413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6f5a2f5c2a3af3e62f16f389489413">&#9670;&#160;</a></span>ConvertUnsignedInt32() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MCORE_INLINE void MCore::Endian::ConvertUnsignedInt32 </td>
          <td>(</td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert one or more 32 bit unsigned integer values into the endian used by our current platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value(s) to convert. The number of values to follow at the specified address must be at least the number that you pass to the count parameter. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the int32 is currently stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of integers to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36eef37ef8d97fe4c19059555ab8e3c4" name="a36eef37ef8d97fe4c19059555ab8e3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36eef37ef8d97fe4c19059555ab8e3c4">&#9670;&#160;</a></span>ConvertUnsignedInt32() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertUnsignedInt32 </td>
          <td>(</td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the endian of one or more unsigned ints. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert the endian for. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to convert. Please note that the array specified by value must be large enough! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a261b229fbe430085efc1b579a97c34dd" name="a261b229fbe430085efc1b579a97c34dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261b229fbe430085efc1b579a97c34dd">&#9670;&#160;</a></span>ConvertUnsignedInt32To()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertUnsignedInt32To </td>
          <td>(</td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a 32 bit uint32 into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f4c77a592c5535f4d8df18cc0c39efa" name="a4f4c77a592c5535f4d8df18cc0c39efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4c77a592c5535f4d8df18cc0c39efa">&#9670;&#160;</a></span>ConvertVector2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertVector2 </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector2 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Vector2 object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the value is currently stored in, before conversion. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92ff210a606c5b34e545a210b7054a90" name="a92ff210a606c5b34e545a210b7054a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ff210a606c5b34e545a210b7054a90">&#9670;&#160;</a></span>ConvertVector2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MCORE_INLINE void MCore::Endian::ConvertVector2 </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector2 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Vector2 object into the endian used by our current platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to convert the endian for. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the object is currently stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7838f0e033ca78cf16b2a1e063f6c21c" name="a7838f0e033ca78cf16b2a1e063f6c21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7838f0e033ca78cf16b2a1e063f6c21c">&#9670;&#160;</a></span>ConvertVector2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertVector2 </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector2 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the endian of one or more Vector2 objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert the endian for. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to convert. Please note that the array specified by value must be large enough! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1abd6c1b59e72bc88228a378b22886a4" name="a1abd6c1b59e72bc88228a378b22886a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abd6c1b59e72bc88228a378b22886a4">&#9670;&#160;</a></span>ConvertVector2To()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertVector2To </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector2 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Vector2 object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8b3eac6b4a2faedb291d497d6b9c042" name="ab8b3eac6b4a2faedb291d497d6b9c042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b3eac6b4a2faedb291d497d6b9c042">&#9670;&#160;</a></span>ConvertVector3() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertVector3 </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Vector3 object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the value is currently stored in, before conversion. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac04c7d611fc97d1869c7641c34b69176" name="ac04c7d611fc97d1869c7641c34b69176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04c7d611fc97d1869c7641c34b69176">&#9670;&#160;</a></span>ConvertVector3() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MCORE_INLINE void MCore::Endian::ConvertVector3 </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a PackedVector3f object into the endian used by our current platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to convert the endian for. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the object is currently stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7fdffda9d0dc06a21512bd9ee16fdc8" name="ab7fdffda9d0dc06a21512bd9ee16fdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fdffda9d0dc06a21512bd9ee16fdc8">&#9670;&#160;</a></span>ConvertVector3() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertVector3 </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the endian of one or more PackedVector3f objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert the endian for. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to convert. Please note that the array specified by value must be large enough! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16b0c300ff797950f959432d440ea72b" name="a16b0c300ff797950f959432d440ea72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b0c300ff797950f959432d440ea72b">&#9670;&#160;</a></span>ConvertVector3To()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertVector3To </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Vector3 object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9031551c5a92c41b8890592b860177a0" name="a9031551c5a92c41b8890592b860177a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9031551c5a92c41b8890592b860177a0">&#9670;&#160;</a></span>ConvertVector4() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertVector4 </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector4 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Vector4 object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the value is currently stored in, before conversion. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03781aad8620dd97e95247f7ae7ccac9" name="a03781aad8620dd97e95247f7ae7ccac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03781aad8620dd97e95247f7ae7ccac9">&#9670;&#160;</a></span>ConvertVector4() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MCORE_INLINE void MCore::Endian::ConvertVector4 </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector4 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>sourceEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Vector4 object into the endian used by our current platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to convert the endian for. </td></tr>
    <tr><td class="paramname">sourceEndianType</td><td>The endian type where the object is currently stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b1465812610793bcf78d8331e63ecef" name="a1b1465812610793bcf78d8331e63ecef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1465812610793bcf78d8331e63ecef">&#9670;&#160;</a></span>ConvertVector4() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertVector4 </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector4 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the endian of one or more Vector4 objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert the endian for. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to convert. Please note that the array specified by value must be large enough! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8624ba4cc6c30b4de6906df3b58c666f" name="a8624ba4cc6c30b4de6906df3b58c666f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8624ba4cc6c30b4de6906df3b58c666f">&#9670;&#160;</a></span>ConvertVector4To()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::ConvertVector4To </td>
          <td>(</td>
          <td class="paramtype">AZ::Vector4 *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_core_1_1_endian.html#aefd74b4672115b5bf5a4f108141fe10d">EEndianType</a>&#160;</td>
          <td class="paramname"><em>targetEndianType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a Vector4 object into another endian type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer to the object to convert/modify. </td></tr>
    <tr><td class="paramname">targetEndianType</td><td>The endian type that the value should be converted into. </td></tr>
    <tr><td class="paramname">count</td><td>The number of objects to convert. This allows conversion of arrays at once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4467fed23e3c1f54f10cb8b1d3d98a8" name="ae4467fed23e3c1f54f10cb8b1d3d98a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4467fed23e3c1f54f10cb8b1d3d98a8">&#9670;&#160;</a></span>SwapBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void Endian::SwapBytes </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>byteA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>byteB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap two bytes values. This means that after executing this method, the memory address of byteA will contain the value of the byte stored at memory address byteB, and the other way around. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteA</td><td>The memory address of byte number one. </td></tr>
    <tr><td class="paramname">byteB</td><td>The memory address of byte number two. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Gems/EMotionFX/Code/MCore/Source/Endian.h</li>
<li>Gems/EMotionFX/Code/MCore/Source/Endian.inl</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>MCore</b></li><li class="navelem"><a class="el" href="class_m_core_1_1_endian.html">Endian</a></li>
    <li class="footer">Generated on Mon Oct 9 2023 13:49:20 for Open 3D Engine EMotionFX Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
